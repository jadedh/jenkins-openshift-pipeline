#!/usr/bin/env python

import subprocess
import sys
import argparse
from jinja2 import Environment
from jinja2 import FileSystemLoader
import re

if len(sys.argv) < 2:
	print 'Pipeline must contain two or more stages'
	sys.exit(1) # abort because of error
def stage_type(x, pat = re.compile(r"[a-z0-9]([-a-z0-9]*[a-z0-9])?")):
 	# regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?')
	if not pat.match(x):
 		print 'Project names may only contain lower-case letters, numbers, and dashes. They may not start or end with a dash.'
		sys.exit(1) # abort because of error
	return x
def gocd_func():
	print 'GoCD'
	return 0
def jenkins_func():
	print 'jenkins pipeline instantiated...'
	# Create & deploy Jenkins
	subprocess.call("oc new-project cicd", shell=True)
	subprocess.call("oc project cicd", shell=True)
	subprocess.call("oc new-app jenkins-persistent", shell=True)

	for arg in args.stages:
		# Create service account
		subprocess.call("oc new-project " + arg, shell=True)
		subprocess.call("oc policy add-role-to-user edit system:serviceaccount:cicd:jenkins -n " + arg, shell=True)

	for y in args.stages[2:]:
		subprocess.call("oc policy add-role-to-group system:image-puller system:serviceaccounts:" +args.stages[0]+" -n "+y, shell=True)
	j2_env = Environment(loader=FileSystemLoader('templates'),trim_blocks=True)
	template = j2_env.get_template('pipeline_template.j2')
	print "Provide your Application name. Name must match the application name created in every stages"
	appname = raw_input("Enter app name:")
	rendered_file = template.render(stages=args.stages,appname=appname)
	print(rendered_file)
	f= open("pipeline-template.yaml", "w+")
	f.write(rendered_file)
	print "Proceed to deploy your applications on the projects"
	#oc new-app jenkins-template.yaml
	#oc start-build pipeline
	return 0

FUNCTION_MAP = {'gocd' : gocd_func,
				'jenkins' : jenkins_func }

parser = argparse.ArgumentParser(description='Build ci/cd pipeline on OpenShift')
parser.add_argument('command', choices=FUNCTION_MAP.keys())
parser.add_argument("stages", type= stage_type, nargs='+',help="stages name for the pipeline")

args = parser.parse_args()

func = FUNCTION_MAP[args.command]
func()
